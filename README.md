# CS250Journal

•	Explain the various roles on a Scrum-agile Team by identifying each role and describing its importance.
o	Product Owner
	The product owner is the ‘middleman’ of the entire operation. This person is the primary point of contact for the entire business side and the rest of the scrum team. They act as translators, communicators, and leaders in order to achieve a great workflow between the business and the rest of the agile team. They set the goals for the products, manage the team backlog, and manage the stakeholders so that the team can stay focused on their tasks at hand. Software development is hard as it is. The Product Owner is the buffer between the development team and the business
o	Scrum Master
	The Scrum Master is the wise teacher/leader of the scrum team. They are there to steer the team in the right direction and to make sure that the team is aligned with the principles of agile. They guide the team to solutions with minimal disturbance. They are there as a helping hand and a mentor for the agile process. They are an important role because they teach the important system that is scrum/agile. This is so important because it is easy to lose sight and fall out of formation. Scum/agile could be taught just once, but its effectiveness in practice would slowly disappear without a scrum master keeping the practice alive. 
o	Development Team
	The development team are the workhorse. They are the ones that type the code on the computer. They are directly responsible for the team’s success and without a development team, software could never get built. However, they work together with the team to be effective individuals. Without the scrum and agile principles, it is easy to get lost and hung up. Progress can be halted by several things, and it’s important to always be working on the next most important thing. Instead of managing this individually, the team comes together to size work and set priorities and goals. This keeps the development team focused and very effective while maintaining an accurate vision of what the business wants.
o	Tester/Testing Team
	The tester usually takes the last step of the development process before releasing the product—testing! Initially, the tester sets conditions for the team and their production. They make sure that the product is meeting all the technical specifications of good, safe, reliable software. During the development process, they work ‘over the shoulder’ of the development team and often might be a full member of the dev team. Throughout the development process, the tester tests each iteration of the code, ensuring the product is working the way it is supposed to. If there are any discrepancies, it is the testers job to relay this information to the dev team or often find a solution on their own. 
•	
Explain how the various phases of the SDLC work in an agile approach. Be sure to identify each phase and describe its importance.
o	Planning
	This is often the first step in the software development life cycle (SDLC). However, some of the other steps such as requirements and design may be bundled into just one step, but many believe that they are so important and deserve their own step. Regardless of how you look at it, planning is exactly what it sounds like. The team gets together and plans the work that needs to get done. Planning involves pulling the bigger goals apart into workable pieces. These pieces are usually determined by the development team while the goals are sources from the business by the product owner. These pieces of work are then sized by the team with the help of the scrum master. It’s important to remember that everyone has a hand in the planning process. It is also important to remember that planning is continuous. Often it will be done once each sprint, but the restructuring of the backlog is a continuous and ever-changing process.
o	Requirements
	Requirements, often associated with the planning step, is the responsibility of the product owner and the dev team. The requirements are often given by the business and stakeholders of the product. They set the boundaries for the scope of the product and often are there to point the development team in the right direction. Requirements can also be conceived by the development team and even the tester(s). They can include hardware limits, operating system restrictions, design adherences, etc. Gathering requirements could technically be considered the first step in the SDLC as they are important for setting the planning in motion. 
o	Design
	Like Requirements, design often happens during the planning phase. This is an important step that is often determined by the business/stakeholders. The look and feel of the application is often determined by the demographic of the expected consumer. This information is sypically passed down to the development team by the product owner, but it is also important to consider that the dev team may have design restrictions of their own. Although we’d like to think so, computers cannot do everything and often times, the business may ask for simply impossible design features. There is often a check and balance that happens between the dev team and the stakeholders that the product owner is responsible for managing. Often design takes place at the beginning of the planning and is one of the very first steps in the SDLC, however it is just as much of a continuous process as the rest of the SDLC. 
o	Build
	Building is the meat and potatoes of the SDLC. Without building , there is no ‘Software’ for the SDLC. Largely the responsibility of the dev team, the scrum master and product owner are all equally responsible for the outcome of the software and therefore also the build process. Building takes place after the planning phase which makes sense, you wouldn’t put the carridge before the horses. However, planning and development actually take turns in the front seat during the SDLC lifecycle. Although it is common to start with planning, it’s also common for there to be multiple iterations of planning and development after the initial planning session as well. This is the essence of continuous integration and allows teams to be truly agile—able to react to any changes or challenges that the team might face down the line. 
o	Document
	An important, yet often overlooked phase of the SDLC is documenting. Although often attributed with the build phase, the documentation phase can take place any time after the software is built and can even make an appearance in in the initial planning phase. Documenting is a very important step because it creates a road map of the software that’s being built. This allows for a lot of important things such as maintainability, growth, and makes it easier for new individuals to quickly join the team and start creating value right away. However, as great as documentation is, it is often an overlooked feature during the SDLC. This is because it is often a nuisance to do for anyone. Most individuals would look at this work and consider it less valuable than picking up a current piece of work on the backlog. Although this may be true for short period of time, over the long term, a lack of documentation can really come back to bite a scrum team in the butt. The value of documentation is not immediately apparent and often doesn’t prove its worth until late into the development process. However, documentation is the single most important thing for the lifespan of an application. Without it, a project will easily get very messy. Worst case scenario, the application ceases to exist within the next 5 years. Best case scenario, the company spends an exuberant load of resources to fix code debt and get back to a ‘stable’ spot, if such a thing even exists anymore. 
o	Test
	Testing is another very important yet sometimes overlooked phase of the SDLC. Testing keeps the application working the way it should. This could be from a security perspective, or even an efficiency perspective. The business and team comes up with goals and requirements for the software to meet. The tester enforces these goals and requirements and often find points of weakness or failure. The tester’s job is important to make sure that the software that is delivered is safe and working the way it is supposed to. They should be looking for all the possible vulnerabilities of an application and attacking each one so that by the time the product is released, the development team can be confident that their work is going to perform as expected and is safe to use. Dev teams often test as they are developing, however it’s important to have a separate individual or even group of individuals as the head testers so that they can focus their efforts solely on testing the application fully. Each piece of development usually requires a certain degree of testing with unit tests. This usually makes sure that there are no discrepancies in the data types and is there to insure that the small portion of the larger project works as expected. However, it is common that things break with the pieces start moving together. This is often not tested until the very end, and this is why it is important to dedicate a whole unit of the team to these efforts if the scope of the project calls for it. Without it, you could very easily release code that is broken or even dangerous to your clients. This is a big deal and is why it is so important to continuously test. 
o	Deploy
	Deploying is one of the ‘last’ steps if there ever was on in the SDLC. Deploying is the process of uploading your software to a given environment. Often, large projects will have multiple environments including test, beta, and finally a production environment. These environments all mirror each other except the purpose of each one is a bit different. Some environments are created so that the testers can accurately test the product in a simulated environment. The test environment is not released to the client and is for the development team only so they can make sure the product will work as expected on the main product environment. Beta environments are very similar and are often the last step before the production environment. They amp up the stakes a bit higher and should almost always mirror the production environment 1:1. They are the last line of defense before an application gets released into ‘the wild’ where it is free game. Again, beta environments are not released to the client yet but act as another environment for rigorous testing to ensure that the application is safe and works as expected. Finally, production is the last environment where the application will live and continuously serve the clients. This is the ‘final product’ per say, however the final product can always be refined and updated. Therefore, the development process is called a ‘life cycle’. These steps repeat repeatedly in the release and maintaining phases. Deploying is the act of getting this software to the different environments so that they can be tested and finally released. It is often the responsibility of the development team as well as the scrum master to continuously deploy and continuously iterate the product so that it can be quickly tested against and deployed.
o	Maintain
	Maintenance is what makes the development process a cycle. Each of these steps are cyclic, but maintenance is what keeps a product never technically in its final state. Once the product is created, it is a living, breathing object that needs to be up kept and enhanced. Maintenance takes the rest of the phases and repeats them repeatedly until the something inevitably dies out. Often, it has been hardware that has died out in the recent years, but as computers reach the limits of their capabilities, we may see competition or even market share of individual operating systems be the fall of software companies. Either way, as a product continues to provide value, it is common for teams to continue maintenance to keep the product alive. This is one of the biggest reasons that the documentation process is so essential. It allows for new individuals to join the team and keeps the progress flowing even if individuals may leave the team.
•	Describe how the process would have been different with a waterfall development approach rather than the agile approach you used. For instance, you might discuss how a particular problem in development would have proceeded differently.
o	The waterfall process has many of the same steps as the agile/scrum process. However, many of these steps are locked in a certain order. For example, once planning is over with the waterfall process, you would not plan again. The rules would often be set in stone from the beginning and the whole development phase would rely on these plans not changing... which doesn’t sound realistic at all in practice. The waterfall method would continue down this chain of steps, never looking back at any of the phases. Like how it would be hard to climb up a waterfall, development under the waterfall method means there’s no turning back. It also means that these phases are often drawn out longer and longer. After all the time spent planning and developing, if your product does not achieve what the partners expected, you are sort of SOL. Agile/scrum allows for flexibility to adapt with the changing needs of multiple different variables. It keeps teams nimble on their feet while also always headed in the correct direction. Although both methods work, the agile process works much more effectively and efficiently and is often chosen over the waterfall method. 
•	Explain what factors you would consider when choosing a waterfall approach or an agile approach, using your course experience to back up your explanation.
o	There are many factors to consider, but the biggest one for this decision in my opinion is the lifespan of the product I am creating. If a project is not planning on being maintained for more than 6 months, it might not be worth it to set up a scrum/agile team and develop with those processes. It may just be easier to plan it all out, develop it, and release it as is. However, if the expectation is for this product to continuously live after 6 months and adapt to new technologies while serving more than just a hand-full of people, I think it is valuable to take the time and resources to create an agile team and work with the agile process.
![image](https://user-images.githubusercontent.com/18557345/164788335-7ea42235-fb78-4f08-a1f7-24ec827f85c1.png)
